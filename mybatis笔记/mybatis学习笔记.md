1.mybatis框架学习目标

1）对于mybatis核心特性和内部功能，熟悉其具体实现采用了哪些设计模式，以及使用这种设计模式的合理性。

2）mybatis的可扩展性，它提供了很多扩展点，比如插件、语言驱动器、执行器、对象工厂、对象包装器工厂，了解了这些就可以进行扩展以满足自己的需求。

2.SqlSessionFactory

1）SqlSessionFactory由SqlSessionFactoryBuilder创建。

2）SqlSessionFactory提供了根据字节流、字符流以及直接使用org.apache.ibatis.session.Configuration配置类三种途径读取配置信息方式。不管那种途径，都是解析XML配置文件构建为Configuration并设置到SqlSessionFactory的默认实现DefaultSqlSessionFactory的configuration中。

3）解析XML的工作都委托给了XMLConfigBuilder。XMLConfigBuilder以及解析Mapper文件的XMLMapperBuilder都继承于BaseBuilder，它们对于XML文件本身技术上的加载和解析都委托给了XpathPaser，使用的是JDK自带的xml解析器，底层使用了Xpath方式进行节点解析。

4)XpathPaser拥有默认的解析器。

3.Configuration

1）在XMLconfigBuilder中进行配置文件的解析parse方法，返回Configuration对象。

2）从DTD文件可知，mybatis-config文件最多有11个配置项，分别是properties、settings、typealiases、typehandlers、objectfactory、objectwrapperfactory、reflectorfactory、plugins、environments、databaseidprovider、mappers。

3)mybatis所有环境配置、resultMap集合、sql语句几个、插件列表、缓存、加载的xml列表、类型别名、类型处理器等全部维护在Configuration中。Configuration中包含了一个静态内部类StrictMap，它继承于HashMap，对于HashMap的装饰在于增加了put时防重复的处理，get时取不到值时候的异常处理。从涉及上说，我们可以说Configuration并不是一个thin类(也就是仅包含了属性以及get/set方法)，而是一个rich类，它对部分逻辑进行了封装便于用户直接使用，而不让用户各自散落处理。

4)从Configuration构造器和protected final TypeAliasRegistry typeAliasRegistry = new TypeAliasRegistry(); 可以看出，所有我们在mybatis-config和mapper文件中使用的类似int/string/JDBC/POOLED等字面量最终解析为具体的java类型都是在类型别名注册器构造期间初始化的。

4.VFS

1)VFS主要用来加载容器内的各种资源，比如jar或者class文件。mybatis提供了2个实现JBOSSVFS和DefaultVFS，并提供了用户拓展点，用于实现自定义VFS实现，加载顺序是自定义VFS实现>默认VFS实现 取第一个加载成功。

5.TypeAlias

1）类型别名是为了减少类全限定名的冗余

6.加载pluginElement

1）mybatis调用pluginElement(Root.evalNode("plugins"));加载插件。

2）插件在具体实现时，使用的是拦截器模式，要注册为mybatis插件，必须要实现interceptor接口。

7.对象工厂

1）对象工厂，就是用于创建结果对象的工厂，默认是使用DefaultObjectFactory来实现，我们可以通过继承DefaultObjectFactory来实现自己的一些行为。

7.创建对象包装器工厂

1）对象包装器工厂主要是用来包装返回result对象，比如说可以用来设置某些敏感字段脱敏或者加密等。默认对象包装器工厂是DefaultObjectWrapperFactory。

2）BeanWrapper是BaseWrapper的默认实现。其中的两个关键接口是getBeanProperty和setBeanProperty，它们是实现包装的主要位置。

3）要实现自定义的对象包装器工厂，只要实现ObjectWrapperFactory中的两个接口hasWrapperFor和getWrapperFor即可。

8.反射工厂ReflectorFactoryElement

1)为了加载配置文件中的各种插件等等，为了提供更好的灵活性，mybatis支持用户自定义反射工厂，不过一般来说，使用默认的反射工厂即可。

9.加载环境配置EnvironmentElement

1）环境可以说是mybatis-config配置文件中最重要的部分，它类似于spring和maven中的profile，允许给开发、生产环境同时配置不同的environment，根据不同环境加载不同配置，这也是常见的做法，如果在SqlSessionFactoryBuilder调用期间没有传递使用哪个环境的话，默认会使用一个名为default的环境。找到对应的environment之后，就可以加载事务管理器和数据源了。事务管理器和数据源类型都使用了类型别名，JDBC、POOLED都是在mybatis内置提供的，在Configuration执行期间注册到TypeAliasRegister。

2）mybatis内置提供了JDBC和MANAGED两种事务管理方式，前者用于简单JDBC模式，后者主要用于容器管理事务，一般使用JDBC事务管理方式。mybatis内置提供JNDI、POOLED、UNPOOLED三种数据源工厂，一般情况下使用POOLED数据源。

10.数据库厂商标识加载databaseIdProviderElement

1)Mybatis可以根据不同的数据库厂商执行不同的语句，这样多厂商的支持是基于映射语句中的databaseId属性。Mybatis会加载不带databaseId属性和带有匹配当前数据库databaseId属性的所有语句。如果同时找到带有databaseId和不带databaseId的相同语句，则后者会被舍弃。

11.加载类型处理器typeHandlerElement

1)无论是Mybatis在预处理语句中设置一个参数时，还是从结果集中取出一个值，都会用类型处理器获取的值以合适的方式转换成Java类型。mybatis提供了两种方式注册类型处理器，package自动检索方式和显式定义方式。使用自动检索方式的时候，只能通过注解方式来指定JDBC类型。

2）为了简化使用，mybatis在初始化TypeHandleRegistry期间，自动注册了大部分的常用类型处理器，比如字符串、数字、日期等。对于非标准的类型，用户可以自定义类型处理器来处理。要实现一个自定义类型处理器，只要实现TypeHandle接口，或者集成一个实用类BaseTypeHandle,并将它映射到一个JDBC类型即可。

12.加载mapper文件mapperElement

1）mybatis文件是mybatis框架的核心之处，所有的sql语句都编写在mapper文件之中。

2)对于简单的语句，使用注解代码会更加清晰。然而java注解对于复杂语句比如同时包含了构造器、鉴别器、resultMap来说就会非常混乱，应该限制使用，此时应该使用xml文件，因为注解至少至今为止不像xml、gradle一样能够很好的表示嵌套关系。

3）knowMappers是MapperRegistry的主要字段，维护了Mapper接口和代理类的映射关系，key是mapper接口类，value是MapperProxyFactory。

4）MapperProxyFactory主要是维护mapper接口的方法与对应mapper文件中具体CRUD节点的关联关系。其中每个Method与对应MapperMethod维护在一起。MapperMethod是mapper中具体映射语句节点的内部表示。

13.解析sql片段

1）sql元素可以被用来定义可重用的sql代码段，包含在其他语句中。比如，它常被用来定义重用的列。

14.sqlsource

1）解析xml过程中，解析selectKey节点，会使用语言驱动器创建sqlsource。sqlsource它是一个接口，它代表了从xml或者注解上读取到的sql映射语句的内容，其中参数使用占位符进行了替换，在运行时，其代表的sql会发送给数据库。

2）mybatis提供了两种类型的实现DynamicSqlSource、RowSqlSource。

3）sqlsource是xml文件或者注解方法中映射语句的实现时表示，通过sqlSourcebuilder.parse()方法创建，sqlSourceBuilder中符号解析器将mybatis中的查询参数#{}转换为？，并记录了参数的顺序。它只有一个方法getBoundSql用于获取映射语句对象的各个组成部分。

4）根据SQL语句的类型不同，mybatis提供了多种sqlSource的具体实现。StaticSQLSource：最终静态SQL语句的封装，其他类型的sqlSource最终都委托给StaticSqlSource。RowSqlSource：原始静态SQL语句的封装，在加载时就已经确定了SQL语句，没有、等动态标签和${}SQL拼接,比动态SQL语句要快，因为不需要运行时解析SQL节点。DynamicSqlSource：动态SQL语句的封装，在运行时需要根据参数处理、等标签或者${}SQL拼接之后才能生成最后要执行的静态SQL语句。ProviderSqlSource：当SQL语句通过指定的类和方法获取时（使用@XXXprovider注解），需要使用本类，它会通过反射调用相应的方法得到SQL语句。

15.sql语句解析核心：mybatis语言驱动器XMLlanguageDriver

1)mybatis从3.2开始支持可插拔的脚本语言，因此你可以在一种语言的驱动之后来写基于这种语言的动态sql查询，比如mybatis除了xml以外，还提供了mybatis-velocity，允许使用celocity表达式编写sql语句，可以通过实现languageDriver接口的方式来插入一种语言。

16.BaseBuilder

1）BaseBuilder是所有解析类的MapperBuilderAssistant、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder等父类。

17.ResultMap

1）ResultMap类维护了每个标签中的详细信息，比如id映射、构造器映射以及完整的映射列表、是否有嵌套的ResultMap、是否有鉴别器、是否有嵌套查询。

2）ResultMap除了作为一个ResultMap的数据结构表示外，本身并没有提供额外的功能。

18.ResultMapping

1）ResultMapping代表的是部分映射关系

19.Discriminator

1)鉴别器代表的是某个属性与ResultMap的映射关系

20.Configuration

1）Configuration是mybatis所有配置以及mapper文件的元数据容器。无论是解析mapper文件还是运行时执行SQL语句，都需要依赖与mybatis的环境和配置信息。比如databaseId、类型别名等。mybatis实现将所有这些信息封装到Configuration中并提供了一系列便利的接口方便各方面的调用方使用，这样就避免了各种配置和元数据信息到处散落的凌乱。

21.ErrorContext

1）ErrorContext定义了一个mybatis内部统一的日志规范，记录了错误信息、发生错误涉及的资源文件、对象、逻辑过程、SQL语句以及出错原因，但是它不会影响运行。

22.BoundSQL

1）SqlSource中包含的SQL处理动态内容之后的实际SQL语句，SQL会包含？占位符，也就是最终给JDBC的SQL语句，以及它们的参数信息。

23.SQL语句的执行流程

1）注册驱动->获取jdbc连接->创建参数化预编译sql->绑定参数->发送SQL给数据库进行执行->对于查询，返回结果集

2）mybatis执行SQL语句，首先要拿到代表JDBC底层连接的一个对象，这在mybatis中的实现就是SqlSession。首先调用SqlSessionFactory.openSession拿到一个session，然后在session上执行各种CRUD操作。简单来说，SqlSession就是jdbc连接的代表，openSession()就是获取jdbc连接(其背后可能是从jdbc连接池获取)；session中的各种CRUD方法或者调用mapper的具体方法就是集合了JDBC调用的3、4、5、6步。

24.openSession

1)mybatis提供了两个SqlSessionFactory的实现：SqlSessionManager和DefaultSqlSessionFactory，默认返回时DefaultSqlSessionFactory。

2）sqlSessionFactory接口的定义。主要有多种形式的重载，除了使用默认设置外，可以指定自动提交模式、特定的jdbc连接、事务隔离级别，以及指定的执行器类型。

25.mybatis结果集处理

1）对于结果集处理，mybatis默认提供了DefaultResultSetHandle。

26.动态sql

1）准确的说，只要mybatis的crud语句中包含了动态sql标签或者${}之后，就已经算是动态sql了，所以只要在mybatis加载mapper文件期间被解析为非staticSqlSource，就会被当做动态sql处理，在执行selectXXX或者update/insert/delete期间，就会调用对应的sqlNode接口和TextSqlNode处理各自的标签和${}，并最终将每个sql片段处理到StaticTextSqlNode并生成最终的参数化静态SQL语句为止。所以，在绝大多数非PK查询的情况下，用的都是动态sql。

27.存储过程与函数调用实现

1）如果mappedStatment.statementType类型为CALLABLE，在Executor.doQuery方法中创建语句处理器的时候，就会返回CallableStatementHandle实例，随后在调用语句处理器的初始化语句和设置参数方法时，调用jdbc对应存储过程的prepareCall方法。

28.mybatis事务实现

1）mybatis事务管理模式分为两种，自动提交和手动提交，DefaultSqlSession的openSession重载方法中，提供了一个参数用于控制是否自动提交事务，该参数最终被传递给Connection.setautoCommit方法。返回的事务对象传递给了Executor对象，因为执行器是在事务上下文中执行，所以对于自动提交模式，mybatis不需要去关心。只有非自动管理模式，mybatis才需要关心事务。对于非自动提交模式，通过SqlSession.commit或者rollback发起，在进行提交或者回滚时会调用isCommitOrRollBackRequired判断是否应该提交或者回滚事务。

2）只有非自动提交模式且执行过DML操作或者设置强制提交才会认为应该进行事务提交或者回滚操作。对于不同的执行器，在提交和回滚执行的逻辑不一样，因为每个执行器在一级、二级、语句缓存上的差异。对于简单执行器，除了清空一级缓存外，什么都不做。对于ReUse执行器，关闭每个缓存的statement以释放服务器端语句处理器，然后清空缓存的语句。对于批量执行器，则执行每个批处理语句的excutebatch方法以便真正执行语句，然后关闭statement。上述逻辑执行完成后，会执行提交、回滚操作。对于缓存执行器，在提交、回滚完成之后，会将TransactionCache中的entriesToAddOnCommit列表分别移动到语句对应的二级缓存中或者清空掉。

29.缓存

1）只要实现了org.apache.ibatis.cache.Cache接口，mybatis提供了基本实现org.apache.ibatis.cache.impl.PerpetualCache，内部采用原始HashMap实现。

2）mybatis有一级缓存和二级缓存。一级缓存是SqlSession级别的缓存，不同session之间的缓存数据区域(HashMap)是互不影响的，Mybatis默认支持一级缓存，不需要任何的配置，默认情况下(一级缓存的有效范围可通过参数localCacheScope参数修改，取值为session或者statement)，在一个SQLSession的查询期间，只要没有发生过commit/rollback或者调用close方法，那么mybatis就会先根据执行语句的CacheKey到一级缓存中查找，如果查找到了就直接返回，不到数据库中执行。代码在BaseExecutor.query中。

3）二级缓存是mapper级别的缓存，多个sqlSession可以去操作同一个mapper的sql语句，多个sqlSession可以共用二级缓存，二级缓存是跨sqlSession。二级缓存默认不启用，需要通过在Mapper中明确设置cache，它的实现在CachingExecutor的query方法中

4）在mybatis缓存实现中，缓存键CacheKey的格式为:cacheKey=Id+offset+limit+sql+paramterValues+environmentId。eg:-1445574094:212285810:org.mybatis.internal.example.mapper.UserMapper.getUser:0:2147483647:select lfPartyId,partyName from LfParty where partyName = ?　AND partyName like ? and lfPartyId in ( ?, ?):p2:p2:1:2:development

5)对于一级缓存，commit/rollback都会清空一级缓存；对于二级缓存，DML操作或者显式设置语句层面的flushCache属性都会使得二级缓存失效。

30.执行器

1）mybatis在执行期间主要有四大核心接口对象：执行器Executor，执行器负责整个SQL执行过程的总体控制；参数处理器ParameterHandler，参数处理器负责PreparedStatement入参的具体设置。语句处理器StatementHandler，语句处理器负责和JDBC层具体交互，包括prepare语句，执行语句，以及调用ParameterHandler.parameterize设置参数。结果集处理器ResultSetHandler，结果处理器负责将JDBC查询对象映射到Java对象。

2）什么是执行器？所有我们在应用层通过sqlSession执行的各类SelectXXX和增删改操作在做了动态sql和参数相关的封装处理后，都被委托到具体的执行器去执行，包括一二级缓存的管理，事务的具体管理，statement和具体JDBC层面优化的实现等。所以执行器比较像是sqlSession下的各个策略工厂实现，用户通过配置决定使用哪个策略工厂。只不过执行器在一个mybatis配置下只有一个，这可能会无法适应所有情况，尤其是那些微服务做的不是很好的中小型公司，因为这些系统通常混搭了OLTP和ETL功能。

3）mybatis提供了两种类型的执行器，缓存执行器和非缓存执行器(使用哪个是通过配置文件中settings下的属性defaultExecutorType控制的，默认是simple)，是否使用缓存执行器则是通过执行cacheEnable控制的，默认是true。缓存执行器不是真正功能上独立的执行器，而是非缓存执行器的装饰器模式。

4）从BaseExecutor的定义可以看出：执行器在特定的事务上下文中执行；具有本地缓存和本地出参缓存(任何时候，只要事务提交或者回滚或者执行update或者查询设定了刷新缓存，都会清空本地缓存和本地出参缓存)；具有延迟加载任务；

5）BaseExecutor实现了大部分通用功能本地缓存管理、事务提交、回滚、超时设置、延迟加载等。

6）Executor.SIMPLE：这个执行器类型不做特殊的事情。它为每个语句的每次执行创建一个新的预处理语句；Executor.REUSE：这个执行器类型会复用预处理语句；Executor.BATCH：这个执行器会批量执行所有更新语句，也就是jdbc addBatch API的facade模式。所以这三种类型的执行器可以说是应用于不同的负载场景下，除了SIMPLE类型外，另外两种要求对系统有较好的架构设计，当然也提供了更多的回报。

7）REUSE和SIMPLE在doUpdate/doQuery上有个差别，不再是每执行一个语句就close掉，而是尽可能的根据SQL文本进行缓存并重用，但是由于受苦服务端通常对每个链接以及全局的语句handle的数量有限制，oracle中是open_cursors参数控制，mysql-stmt_close参数控制，这就会导致如果sql都是靠if各种拼接出来，日积月累可能会导致数据库资源耗尽。

8）批量执行器是JDBC Statement.addBatch的实现，对于批量insert而言，比如导入大量数据的ETL，驱动器如果支持的话，能够大幅度提高DML语句的性能。对于MySQL而言，在5.1.13以上的版本的驱动，在连接字符串上rewriteBatchedStatements参数也就是jdbc:mysql://192.168.1.100:3306/test?rewriteBatchedStatements=true后，性能可以提高几十倍。

9）缓存执行器相对于其他执行器的差别在于，首先是在query方法中判断是否使用二级缓存(也就是mapper级别的缓存)。虽然mybatis默认启用了CachingExecutor，但是如果在mapper层面没有明确设置二级缓存的话，就退化为SimpleExecutor了。二级缓存的维护由TransactionalCache(事务化缓存)负责，当在TransactionalCacheManager(事务化缓存管理器)中调用putObject和removeObject方法的时候并不是马上就把对象存放到缓存或者从缓存中删除，而是先把这个对象放到entriesToAddOnCommit和entriesToRemoveOnCommit这个两个hashmap中的一个里，然后当执行commit、rollback方法时再真正的把对象存放到缓存或者从缓存中删除，具体可以参见TransactionalCache.commit、rollback方法。

还有一个差别是使用了TransCacheManager管理事务，其他逻辑就一样了。

31.参数处理器ParameterHandle

1）ParameterHandle只有一个默认实现DefaultParameterHandle。

32.语句处理器

1）从接口可以看出，statementHandle主要包括prepare语句、给语句设置参数、执行语句获取要执行的SQL语句本身。mybatis包含了三种类型的StatmentHandle实现。分别用于JDBC对应的prepareStatement，Statement以及callableStatement。BaseStatementHandle是这三种类型语句处理器的抽象父类，封装了一些实现细节比如设置超时时间、结果集每次提取大小等操作。

33.结果集处理器ResultSetHandle

1）结果集处理器，顾名思义，就是用了对查询结果集进行处理的，目标是将JDBC结果集映射为业务对象。

2）接口中定义的三个接口分别用于处理常规查询的结果集、游标结果集以及存储过程调用的出参设置。和参数处理器一样，结果处理器也只有一个默认实现DefaultResultHandle。结果集处理器的功能包括对象的实例化、属性自动匹配计算、常规属性赋值、嵌套ResultMap的处理、鉴别器结果集的处理等，每个功能在执行selectXXX已经详细讲过。

35.插件

1）插件几乎是所有主流框架提供的一种扩展方式，插件可以用于记录日志、统计运行时性能、为核心功能提供额外辅助支持。在mybatis中，插件是在内部通过拦截器实现的。要开发自定义插件，只要实现org.apache.ibatis.plugin.interceptor接口即可。

2）mybatis提供了为插件配置提供了两个注解:org.apache.ibatis.plugin.Signature和org.apache.ibatis.plugin.intercepts。

3）Intercepts注解它有一个类型为Signature数组的value属性，如果没有指定，它会拦截StatementHandler、ResultSetHandler、ParameterHandler和Executor这四个核心接口对象中的所有方法。如需改变默认行为，可以通过明确设置value的值。

4）Signature使用示例

@Intercepts({@Signature(type = StatementHandler.class, method = "prepare", args = {Connection.class}),        @Signature(type = ResultSetHandler.class, method = "handleResultSets", args = {Statement.class})})
