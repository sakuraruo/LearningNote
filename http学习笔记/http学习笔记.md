一、TCP和UDP有哪些区别？

1）TCP是面向连接的，UDP是面向无连接的。所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。

2）TCP提供可靠交付。通过TCP连接传输的数据，无差错、不丢失、、不重复、并且按序到达。而UDP继承了IP包的特性，不保证不丢失，不保证按顺序到达。

3）TCP是面向字节流的。发送的时候发的是一个流。IP包不是一个流，而是一个个IP包，之所以变成了流，这也是TCP自己的状态维护做的事情。而UDP继承了IP的特性，基于数据包，一个个发，一个个收。

4）TCP是可以有拥塞控制的。它意识到包丢弃了或者网络环境不好，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点。UDP就不会，应用让我发，我就发。



二、UDP的三大特点

1）沟通简单 2）轻信他人 3）愣头青，做事不懂权变



三、UDP的三大使用场景

1）需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用。

2）不需要一对一沟通，建立连接，而是可以广播的应用。

3）需要处理速度快，时延低，可以容忍少数丢包，但是要求即使网络拥塞



四、TCP包头格式

![image-20220405210547928](C:\Users\ogiso\IdeaProjects\LearningNote\http学习笔记\pic\image-20220405210547928.png)

1）首先是源端口号和目标端口号，这个和UDP是一样的。

2）包的序号，这是为了解决乱序的问题。

3）确认序号，用于确定包是否有收到，这个可以解决不丢包的问题。

4）状态位：SYNC是发起一个连接、ACK是回复、RST是重新连接、FIN是结束连接。TCP是面向连接的，因此双方都要维护连接的状态，这些带状态位的包的发送，会引起双方状态的变更。

5）窗口大小。TCP要做流量控制，通信双方各声明一个窗口，标识自己当前能够处理的能力。控制发送的速度。



五、TCP需要关注的几个问题

1）顺序问题，稳重不乱

2）丢包问题，承诺靠谱

3）连接维护，有始有终

4）拥塞控制，知进知退



六、TCP的三次握手

TCP的连接建立，我们通常称为三次握手。

A：你好，我是A

B：你好，我是B

A：你好，B

![image-20220405212812430](C:\Users\ogiso\IdeaProjects\LearningNote\http学习笔记\pic\image-20220405212812430.png)

1）客户端和服务端都处于close状态，先是服务端主动监听某个端口，处于listen状态。

2）客户端主动发起连接SYN，之后处于SYN-SENT状态。

3）服务端收到发起的连接，返回SYN，并且ACK客户端的SYN，之后处于SYN-RCVD状态。

4）客户端收到服务端发送的SYN和ACK之后，发送ACK的ACK，之后处于ESTABLISHED状态

5）服务端收到ACK的ACK之后，处于ESTATBLISHED状态，双方就可以开始通信了。



七、TCP的四次挥手

A:B啊，我不想玩了

B：哦，你不想玩了，我知道了

这个时候，还只是A不想玩了，也即A不会再发送数据，但是B能不能在ACK的时候直接关闭呢？当然不可以，很有可能是A发完了最后的数据就准备不玩了，但是B还没做完自己的事情，还是可以发送数据的，所以称为半关闭状态。

B：A啊，好吧，我也不玩了，拜拜

A：拜拜

![image-20220405214500090](C:\Users\ogiso\IdeaProjects\LearningNote\http学习笔记\pic\image-20220405214500090.png)

1）断开的时候，我们可以看到，当A说“不玩了”，就进入FIN_WAIT_1状态。

2）B收到“A不玩了”的消息后，发送知道了就进入了CLOSE_WAIT状态。

3）A收到“B知道了”，就进入FIN_WAIT_2的状态，如果这个时候B直接跑路，则A将永远在这个状态。TCP协议离没有对这个状态的处理，但是Linux有，可以调整tcp_fin_timeout参数，设置一个超时时间。

如果B没有跑路，发送了“B也不玩了”的请求到达A时，A发送“知道B也不玩了”的ACK后，从FIN_WAIT_2状态结束，按说A可以跑路了，但是最后的这个ACK万一B收不到怎么办呢？因而TCP协议要求A最后等待一段时间TIME_WAIT，这个时间要足够长，长到如果B没收到ACK的话，“B说不玩了”会重发的，A会重新发一个ACK并且足够时间到达B。



八、TCP的可靠实现原理

TCP协议为了保证顺序性，每一个包都有一个ID。在建立连接的时候，会商定起始的ID是什么，然后按照ID一个个发送。为了保证不丢包，对于发送的包都要进行应答，但是这个应答也不是一个一个来的，而是会应答某个之前的ID，表示都收到了，这种模式称为累计确认和累计应答。

为了记录所有发送的包和接收的包，TCP也需要发送端和接收端分别都有缓存来保存这些记录。发送端的缓存里是按照包的ID一个个排列，根据处理的情况分成四个部分。

第一部分：发送了并且已经确认的，这是你交代下属的，并且也做完了的，应该划掉的。

第二部分：发送了并且尚未确认的。这部分是你交代下属的，但是还没做完的，需要等待做完的回复之后，才能划掉。

第三部分：没有发送，但是已经等待发送的。这部分是你还没有交代给下属，但是马上就要交代的。

第四部分：没有发送，并且暂时还不会发送 。这部分是你还没有交代给下属，而且暂时还不会交代给下属的。

在TCP里，接收端会给发送端报一个窗口的大小，交Advertised window。这个窗口的大小应该等于上面的第二部分加上第三部分，就是已经交代了没做完的加上马上要交代的。超过这个窗口的，接收端做不过来，就不能发送了。

顺序问题与丢包问题

TCP为了解决这个问题，使用了超时重试机制，即对每一个发送了，但是没有ACK的包，都设置有一个定时器，超过一定的时间，就重新尝试。达到你是这个超时的时间如何评估呢？这个时间不宜过短，时间必须大于往返时间RTT，否则会引起不必要的重传。也不宜不过，这样超时时间变长，访问就会变慢。

估计往返时间，需要TCP通过采样RTT的时间，然后进行加权平均，算出一个值，而且这个值还是要不断变化的，因为网络状况不断的变化，除了采样RTT，还要采样RTT的波动范围，计算一个估计的超时时间。由于重传时间不断变化，我们称为自适应重传算法。

TCP的策略是超时间隔加倍。每次遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。

流量控制问题

发送方的滑动窗口是可调节的，会根据在目前已经发送未确认的数据、未发送可以发送的大小进行调节，进行发送行为。

拥塞控制

拥塞控制问题，也是通过窗口的大小来控制的，前面的滑动窗口rwnd是怕发送方把接收方缓存填满，而拥塞窗口cwnd，是怕把网络塞满。

为了解决这些问题，有了TCP BBR拥塞算法。它企图找到一个平衡点，就是通过不断的加快发送速度，将带宽利用好，但是不要填满中间设备的缓存，因为这样时延会增加，在这个平衡点就可以很好的达到高带宽和低延时的平衡。



九、HTTP 2.0

HTTP 1.1在应用层以纯文本的形式进行通信。每次通信都要带完整的HTTP头，而且不考虑pipeline模式的话，每次的过程总是像上面描述的那样一去一回。这样在实时性、并发性上都存在问题。

为了解决这些问题，HTTP2.0会对HTTP头进行一定的压缩，将原来每次都要携带大量的KV在两端建立一个索引表，对相同的头只发送索引表中的索引。

HTTP2.0协议将一个TCP的连接中，切分成多个流，每个流都有自己的ID，而且流可以是客户端发往服务端，也可以是服务端发往客户端

HTTP2.0还将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。常见的帧有Header帧，用于传输Header内容，并且会开启一个新的流。再就是Data帧，用来传输正文实体。多个Data帧属于同一个流。

通过这两种机制，HTTP2.0客户端可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。这些帧可以打散乱序发送，然后根据每个帧首部的流标识符进行重新组装，并且可以根据优先级，决定优先处理哪个流的数据。

HTTP2.0通过头压缩、分帧、二进制编码、多路复用等技术提升性能。



十、HTTPS协议

对称加密：再对称加密算法中，加密和解密使用的密钥是相同的。也就是说，加密和解密使用的是同一个密钥。因此，对称加密算法要保证安全性的话，密钥要保留好。只能让使用的人知道，不能对外公开。

非对称加密：再非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。一把是作为公开的公钥，另一把是作为谁都不能给的私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。

数字证书

不对称加密也会有同样的问题，如何将不对称机密的公钥给对方呢？一种是放在公网的地址上，让对方下载；另外一种就是在建立连接的时候传给对方。

这两个方法有相同的问题，那就是，作为一个普通网民，你怎么鉴别别人给你的公钥是对的。会不会有人冒充网站，发给你一个它的公钥。接下来，你和它所有的互通，看起来都是没有任何问题的。毕竟每个人都可以创建自己到底公钥和私钥。

HTTPS大的工作模式

我们可以知道，非堆成加密在性能上不如对称加密，那是否能将两者结合起来呢？例如，公钥私钥主要用于传输对称加密的密钥，而真正的双方大数据量的通信都是通过对称加密进行的。

![image-20220406122336993](C:\Users\ogiso\IdeaProjects\LearningNote\http学习笔记\pic\image-20220406122336993.png)