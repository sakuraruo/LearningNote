一、技术概述

1.Java虚拟机与系统级虚拟机的区别

Java虚拟机只是面向单一应用程序的虚拟机，但是和系统级虚拟机一样，我们也可以为其分配实际的硬件资源，比如最大的内存大小等。Java虚拟机没有使用传统的PC架构，比如现在的HotSpot虚拟机。实际上采用的是 基于栈的指令集架构 ，而我们传统程序设计一般都是基于寄存器的指令集架构。

tips: 通过查看java字节码 会发现局部变量表中存放了this。

2.jvm运行字节码的一些说明

jvm运行字节码时，所有的操作都是围绕两种数据结构，一种是堆栈(本质上时栈结构)，还有一种是队列。如果JVM执行某条指令时，该指令需要对数据进行操作，那么被操作的数据在指令执行前，必须要压到堆栈上，jvm会自动将栈顶数据作为操作数，如果堆栈上的数据需要暂时保存起来，那么它就会被存储到局部变量队列上。

二、什么是即时编译器

jvm会根据当前代码进行判断，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器(Just Time Compiler)。

![](C:\Users\ogiso\IdeaProjects\LearningNote\jvm学习笔记\pic\1.jpg)



tips: Jdk1.4时，Sun Classic VM完全退出了历史舞台，取而代之的时至今狗仔使用的HotSpot VM，它时目前使用最广泛的虚拟机，拥有热点代码探测技术、准确式内存管理(虚拟机可以知道内存中某个位置的数据具体是什么类型)等技术。

三、虚拟机发展的未来

2018年4月，Oracle Labs公开了最新的GraalVM，它是一种全新的虚拟机，它能够实现所有的语言统一运行在虚拟机中。

四、jvm启动流程探究

JLI_Launch最初的启动类->SelectVersion选择JRE版本->CreateExecutionEnvironment创建JVM执行环境->Load javaVM 加载JVM->JVMinit 初始化JVM->ContinueInNewThread->ContinueInNewThread0->JavaMain真正开始执行Java程序->InitializeJVm初始化虚拟机->loadMainClass加载主类->GetApplicationClass->Post JVMInit->GetStaticMethodID->CallStaticVoidMethod执行主方法->Leave程序执行结束、结束线程、销毁线程。

五、JNI调用本地方法

java有一个JNI机制，它的全程：java native interface，即java本地接口，它允许在java虚拟机内运行的java代码与其他编程语言如(C/C++和汇编语言)编写的程序和库进行交互(在Android开发中比较多)。

六、JVM内存管理

内存区域划分：既然要管理内存，那肯定不是杂乱无章的，jvm对内存的管理采用的是分区治理，不同的内存区域有着各自的职责所在，在虚拟机运行时，内存区域如下：

![image-20220324170033919](C:\Users\ogiso\IdeaProjects\LearningNote\jvm学习笔记\pic\2.png)

程序计数器：

它和我们传统8086 CPU寄存器的工作差不多，因为JVM虚拟机的目的就是实现物理机那样的程序执行；在8086 CPU中，PC作为程序计数器，负责存储内存地址，该地址指向下一条即将执行的指令，每解释完一条指令，PC寄存器就会自动更新为下一条指令的地址，进入下一个指令周期时，就会根据当前地址所指向的指令进行执行。而JVM中的程序计数器可以看作是当前线程所执行字节码的行号指示器，而行号正好就指的是某一条指令，字节码解释器在工作时也会改变这个值，来指定下一条即将执行的指令。

虚拟机栈：

虚拟机栈式一个非常关键的部分，它是一个栈结构，每个方法被执行的时候，java虚拟机都会同步创建一个栈帧(其实就是栈里面的一个元素)，栈帧包括了当前方法的一些信息，比如局部变量表、操作数栈、动态链接、方法出口等。

![image-20220324171525013](C:\Users\ogiso\IdeaProjects\LearningNote\jvm学习笔记\pic\3.png)

局部变量表：就是方法中的局部变量，在class文件中已经定义好了；

操作数栈：就是我们字节码执行时使用到的栈结构；

栈帧：每个栈帧还保存了一个可以执行当前方法所在类的运行时常量池，目的是：当前方法中如果需要调用其他方法时，就能够从运行时常量池中找到对应的符号引用，再将符号引用转换为直接引用，然后就能直接调用对应方法，这就是动态链接；

方法出口：方法该如何结束，是抛出异常还是正常返回；

流程分析：

从字节码文件分析，在编译之后，整个方法的最大操作数栈深度、局部变量表都是确定好的，当我们程序开始执行时，会根据这些信息封装为对应的栈帧。



堆：

堆是整个Java应用程序共享的区域，也是整个虚拟机最大的一块内存空间，此区域的职责就是存放和管理对象和数组。垃圾回收主要也是作用于这一部分内存区域。



方法区：

方法区也是整个Java应用程序共享的区域，它用于存储所有的类信息、常量、静态常量、动态编译缓存等数据。可以大致分为两个部分，一个是类信息表、一个是运行时常量池。

![image-20220324182344520](C:\Users\ogiso\IdeaProjects\LearningNote\jvm学习笔记\pic\4.png)

类信息表存放的时当前应用程序加载的所有类信息，包括类的版本、字段、方法、接口等信息，同时会将编译时生成的常量池数据全部存放到运行时常量池。当然，常量也并不是只能从类信息中获取，在运行时，也有可能会有新的常量加入到常量池中。

！！！jdk7之后祖父穿常量池从方法区移动到了堆中。



本地方法栈：

等同于方法区，只不过是作用于本地方法。

tips：设置堆内存为-xms -xmx 设置栈容量为-xss



堆外内存：

通过Unsafe类来操作堆外内存(直接内存)



六、垃圾回收机制

对象存活判定算法

引用计数法：

每一个对象都包含一个引用计数器，用于存放引用计数(其实是存放被引用的次数)

每当有一个地方引用此的对象时，引用次数+1

当引用失效(比如离开了局部变量的作用域或者引用被设定为null)，引用计数-1

当引用计数为0时。表示此对象不可能再被使用，因为这时已经没有任何方法可以得到此对象的引用了

引用计数存在互相引用时，哪怕无法被访问，它们的引用计数还是为1，所以引用计数方案不是最好的解决方案

可达性分析算法：

目前比较主流的编程语言(包括Java)，一般都会使用可达性分析算法发来判断对象是否存活，它采用了类似于树结构的搜索机制。

首先每个对象的引用都有机会成为树的根节点(GC ROOT)，可以被选定作为根节点的条件如下：

1）位于虚拟机栈的栈帧中的本地变量表中所引用到的对象(其实就是我们方法中的局部变量)，同样也包括本地方法栈中JNI引用的对象。

2）类的静态成员变量引用的对象。

3）方法区中，常量池里面引用的对象，比如我们之前提到的String对象。

4）被添加了锁的对象(比如synchronized关键字)

5）虚拟机内部需要用到的对象

一旦已经存在的根节点不满足存在的条件时，那么根节点与的对象之间的连接将被断开。此时虽然对象1仍存在堆其他对象的引用，但是由于其没有任何根节点引用，所以此对象即可被判定为不再使用。比如某个方法中的局部变量引用，再方法执行完成返回之后。

总结：如果某个对象无法到达任何GC ROOT，则证明该对象不可能再被使用。



最终判定

虽然再经历了可达性分析算法之后基本可以判定哪些对象能够被回收，但是并不代表此对象一定会被回收，我们依然可以在最终判定阶段对其进行挽留。















